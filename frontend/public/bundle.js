!function(){"use strict";class e{device;objects;constructor(e){this.device=e,this.objects=[],console.log("Scene created.")}addObject(e){this.objects.push(e)}removeObject(e){const t=this.objects.indexOf(e);t>-1&&this.objects.splice(t,1)}getObjects(){return this.objects}draw(e){for(const t of this.objects)t.draw(e)}}class t{device;pipeline;vertexBuffer;color;position;orientation;constructor(e,t,i){this.device=e,this.color=new Float32Array(t),this.position=new Float32Array(i),this.createVertexBuffer(),this.createPipeline()}createVertexBuffer(){const e=new Float32Array([0+this.position[0],.5+this.position[1],this.position[2],1,-.5+this.position[0],-.5+this.position[1],this.position[2],1,.5+this.position[0],-.5+this.position[1],this.position[2],1]);this.vertexBuffer=this.device.createBuffer({size:e.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(e),this.vertexBuffer.unmap()}createPipeline(){const e=`\n            @fragment\n            fn fs_main() -> @location(0) vec4<f32> {\n                return vec4<f32>(${this.color.join(",")});\n            }\n        `;this.pipeline=this.device.createRenderPipeline({label:"triangle-pipeline",layout:"auto",vertex:{module:this.device.createShaderModule({code:"\n            @vertex\n            fn vs_main(@location(0) position: vec4<f32>) -> @builtin(position) vec4<f32> {\n                return position;\n            }\n        "}),entryPoint:"vs_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,offset:0,format:"float32x4"}]}]},fragment:{module:this.device.createShaderModule({code:e}),entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}})}draw(e){e.setPipeline(this.pipeline),e.setVertexBuffer(0,this.vertexBuffer),e.draw(3,1,0,0)}}class i{device;pipeline;vertexBuffer;indexBuffer;color;position;radius=.5;numIndices;constructor(e,t,i,n){this.device=e,this.color=new Float32Array(t),this.position=new Float32Array(i),this.radius=n,this.createVertexBuffer(),this.createPipeline()}createVertexBuffer(){const e=32,t=[],i=[];for(let i=0;i<=e;i++){const n=i*Math.PI/e,r=Math.sin(n),s=Math.cos(n);for(let i=0;i<=e;i++){const n=2*i*Math.PI/e,o=Math.sin(n),a=Math.cos(n),c=this.radius*a*r,d=this.radius*s,h=this.radius*o*r;t.push(c+this.position[0],d+this.position[1],h+this.position[2],1)}}for(let t=0;t<e;t++)for(let n=0;n<e;n++){const r=33*t+n,s=r+e+1;i.push(r,s,r+1),i.push(s,s+1,r+1)}this.numIndices=i.length,this.vertexBuffer=this.device.createBuffer({size:4*t.length,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(new Float32Array(t)),this.vertexBuffer.unmap(),this.indexBuffer=this.device.createBuffer({size:4*i.length,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint32Array(this.indexBuffer.getMappedRange()).set(new Uint32Array(i)),this.indexBuffer.unmap()}createPipeline(){const e=`\n            @fragment\n            fn fs_main() -> @location(0) vec4<f32> {\n                return vec4<f32>(${this.color.join(",")});\n            }\n        `;this.pipeline=this.device.createRenderPipeline({layout:"auto",label:"sphere-pipeline",vertex:{module:this.device.createShaderModule({code:"\n            @vertex\n            fn vs_main(@location(0) position: vec4<f32>) -> @builtin(position) vec4<f32> {\n                return position;\n            }\n        "}),entryPoint:"vs_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,offset:0,format:"float32x4"}]}]},fragment:{module:this.device.createShaderModule({code:e}),entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}})}draw(e){e.setPipeline(this.pipeline),e.setVertexBuffer(0,this.vertexBuffer),e.setIndexBuffer(this.indexBuffer,"uint32"),e.drawIndexed(this.numIndices)}}class n{canvas;context;device;swapChainFormat="bgra8unorm";scene;constructor(n){this.canvas=document.getElementById(n),this.initializeWebGPU().then((()=>{this.clearCanvas(),this.scene=new e(this.device);const n=new t(this.device,[1,0,0,1],[.5,.5,0]),r=new t(this.device,[1,0,1,1],[0,0,0]),s=new i(this.device,[0,1,0,1],[0,0,0],.2);this.scene.addObject(n),this.scene.addObject(r),this.scene.addObject(s),this.startRenderingLoop()})).catch((e=>{console.error("Failed to initialize WebGPU:",e)}))}async initializeWebGPU(){if(!navigator.gpu)throw new Error("WebGPU is not supported.");const e=await navigator.gpu.requestAdapter();if(!e)throw new Error("Failed to get GPU adapter.");this.device=await e.requestDevice(),this.context=this.canvas.getContext("webgpu");window.devicePixelRatio;this.canvas.clientWidth,this.canvas.clientHeight;const t={device:this.device,alphaMode:"opaque",format:this.swapChainFormat};this.context.configure(t)}clearCanvas(){const e=this.device.createCommandEncoder(),t={colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]};e.beginRenderPass(t).end();const i=e.finish();this.device.queue.submit([i])}startRenderingLoop(){const e=()=>{this.render(),requestAnimationFrame(e)};requestAnimationFrame(e)}render(){const e=this.device.createCommandEncoder(),t={colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]},i=e.beginRenderPass(t);this.scene.draw(i),i.end();const n=e.finish();this.device.queue.submit([n])}}(async function(){if(!navigator.gpu)return console.error("WebGPU is not supported on this device!"),!1;try{const e=await navigator.gpu.requestAdapter();if(!e)return console.error("Failed to get GPU adapter!"),!1;if(!await e.requestDevice())return console.error("Failed to get GPU device!"),!1}catch(e){return console.error("An error occurred while initializing WebGPU:",e),!1}return console.log("WebGPU is supported."),!0})().then((e=>{e?(console.log("Loading rendering engine..."),new n("gpuCanvas")):console.log("Rendering engine cannot be loaded due to lack of WebGPU support.")}))}();
//# sourceMappingURL=bundle.js.map
